# Elements

_This module contains the classes representing the elements of the diagram._

## Imports

The following imports are used:

- `Enum`: to define enums.
- `re`: to use regular expressions.
- `Optional`: to indicate that a variable may be `None`.
- `List`: to indicate that a variable is a list.

```python
from enum import Enum
import re
from typing import Optional, List
```

## Overview

The following elements are defined:

- [`Element`](#element-base-class)
- [`Interface`](#interface)
- [`Message`](#message)
- [`State`](#state)
- [`ChoicePoint`](#choice-point)
- [`Transition`](#transition)

in the following sections, the classes are described in detail.

## Enums

The following enums are defined:

- `ElementType`: an enum containing the types of the elements.
- `ConnectorType`: an enum containing the types of the connectors.
- `CodeType`: an enum containing the types of the code.

The `ElementType` enum is defined as follows:

```python
class ElementType(Enum):
    INTERFACE = "Interface"
    MESSAGE = "Message"
    STATE = "State"
    CHOICE_POINT = "ChoicePoint"
    TRANSITION = "Transition"
```

The `ConnectorType` enum is defined as follows:

```python
class ConnectorType(Enum):
    LEFT = "Left"
    RIGHT = "Right"
    UP = "Up"
    DOWN = "Down"
```

The `CodeType` enum is defined as follows:

```python
class CodeType(Enum):
    STANDARD = "Standard"
    SELECTED = "Selected"
    MASKED = "Masked"
```

## Element base class

The `Element` class is the base class for all elements in the diagram.

### Attributes

The `Element` class has the following attributes:

- `element_type`: an enum containing the type of the element (e.g. `Interface`, `Message`, `State`, `ChoicePoint`, or `Transition`).
- `identifier`: an integer containing the identifier of the element.

### Constructor

The constructor of the class takes the type of the element and the optional identifier as arguments.

```python
def __init__(self, element_type: ElementType, identifier: int = 0):
```

### Methods

The `Element` class has the following methods:

- `get_plantuml_code(code_type: CodeType = CodeType.STANDARD)`: returns the PlantUML code of the element, depending on the type of the code. This is overridden by the subclasses.
- `get_variable_name()`: returns the variable name of the element. This is overridden by the subclasses.
- `from_plantuml_code(plantuml_code: str)`: classmethod that sets the attributes of the element from the PlantUML code. This is overridden by the subclasses.

## Interface

The `Interface` class is a subclass of `Element` with the type set to `Interface` and is responsible for holding the data of an interface. 

It has the following additional attributes:

- `name`: a string containing the name of the interface.

### Constructor

The constructor of the class takes the following arguments:

```python
    def __init__(self, name: str, identifier: int = 0):
        super().__init__(ElementType.INTERFACE, identifier)
        self.name = name
```

### Methods

The `Interface` class has the following methods:

- [`get_plantuml_code(code_type: CodeType = CodeType.STANDARD)`](#get-interface-plantuml-code): returns the PlantUML code of the interface, depending on the type of the code.
- [`get_variable_name()`](#get-interface-variable-name): returns the variable name of the interface.
- [`from_plantuml_code(plantuml_code: str)`](#set-interface-from-plantuml-code): classmethod that sets the attributes of the interface from the PlantUML code.

### Get interface PlantUML code

An interface is represented by a variable in the PlantUML code for example:

```
!$RTx = RTx
```

This does not depend on the type of the code.

To generate this code the following method is used:

```python
def get_plantuml_code(self, code_type: CodeType = CodeType.STANDARD) -> str:
```

The method returns the PlantUML code of the interface which is specified as follows:
```python
return f"!{self.get_variable_name()} = {self.name}"
```

### Get interface variable name

For an interface the variable name is `$<name>`. This is generated by the following method:

```python
def get_variable_name(self) -> str:
    return f"${self.name}"
```

### Set interface from PlantUML code

To set the attributes of the interface from the PlantUML code, the following method is used:

```python
@classmethod
def from_plantuml_code(cls, plantuml_code: str):
```

The method splits the `plantuml_code` at the `=` character and then sets the `name` attribute to the part after the `=` character.

```python
name = plantuml_code.split("=")[1].strip()
```

The identifier is set to default value of `0` as this is not used for an interface.

```python
identifier = 0
```

The class method can then be called with the `cls` parameter set to `Interface`.

```python
return cls(identifier, name)
```

## Message

The `Message` class is a subclass of `Element` with the type set to `Message` and is responsible for holding the data of a message. 

### Attributes

The `Message` class has the following additional attributes:

- `name`: a string containing the name of the message.
- `interface`: an optional string containing the variable name of the interface of the message.

### Constructor

The constructor of the class takes the following arguments:

```python
    def __init__(self, identifier: int, name: str, interface: str | None = None):
        super().__init__(ElementType.MESSAGE, identifier)
        self.name = name
        self.interface = interface
```

### Methods

The class has the following methods:

- [`get_plantuml_code(code_type: CodeType = CodeType.STANDARD)`](#get-message-plantuml-code): returns the PlantUML code of the message, depending on the type of the code.
- [`get_variable_name()`](#get-message-variable-name): returns the variable name of the message.
- [`from_plantuml_code(plantuml_code: str)`](#set-message-from-plantuml-code): classmethod that sets the attributes of the message from the PlantUML code.

### Get message PlantUML code

A message is represented by a variable in the PlantUML code for example:

```
!$RTx_ConnectReq = $RTx + ":" + ConnectReq
```

This does not depend on the type of the code.

To generate this code the following method is used:

```python
def get_plantuml_code(self, code_type: CodeType = CodeType.STANDARD) -> str:
```

The method returns the PlantUML code of the message which is specified as follows:

```python
return f"!{self.get_variable_name()} = {self.interface} + \":\" + {self.name}"
```

### Get message variable name

A message is represented by a variable in the PlantUML code for example:

```
$RTx_ConnectReq
```

For a message the variable name is `$<interface>_<name>` unless the interface is `None`. This is generated by the following method:

```python
def get_variable_name(self) -> str:
    if self.interface:
        return f"{self.interface}_{self.name}"
    return f"${self.name}"
```

### Set message from PlantUML code

To set the attributes of the message from the PlantUML code, the following method is used:

```python
@classmethod
def from_plantuml_code(cls, plantuml_code: str):
```

An example of the code that needs to be set is:

```
!$RTx_ConnectReq = $RTx + ":" + ConnectReq
```

The method finds the index of the last `_` character and then sets the `name` attribute to the part after the last `_` character and before the `=` character.

```python
name = plantuml_code[plantuml_code.rfind("_") + 1:plantuml_code.find("=")].strip()
```

The interface is set to the part before the last `_` character and then the `!$` is removed.

```python
interface = plantuml_code[:plantuml_code.rfind("_")].strip()
interface = interface[2:]
```

The identifier is set to default value of `0` as this is not used for a message.

```python
identifier = 0
```

The class method can then be called with the `cls` parameter set to `Message`.

```python
return cls(identifier, interface, name)
```

## State

The `State` class is a subclass of `Element` with the type set to `State` and is responsible for holding the data of a state.

### Attributes

The `State` class has the following additional attributes:

- `name`: a string containing the name of the state.
- `display_name`: a string containing the display name of the state.

### Constructor

The constructor of the class takes the following arguments:

```python
    def __init__(self, identifier: int, name: str, display_name: str | None = None):
        super().__init__(ElementType.STATE, identifier)
        self.name = name
        self.display_name = display_name
```

### Methods

The `State` class has the following methods:

- [`get_plantuml_code(code_type: CodeType = CodeType.STANDARD)`](#get-state-plantuml-code): returns the PlantUML code of the state, depending on the type of the code.
- [`get_variable_name()`](#get-state-variable-name): returns the variable name of the state.
- [`from_plantuml_code(plantuml_code: str)`](#set-state-from-plantuml-code): classmethod that sets the attributes of the state from the PlantUML code.

### Get state PlantUML code

For `code_type` set to `STANDARD` a state is represented by a variable in the PlantUML code for example:

```
state Connecting
```

For `code_type` set to `SELECTED` a state is represented by a variable in the PlantUML code for example:

```
state Connecting #line:FF0000;line.bold
```

For `code_type` set to `MASKED` a state is represented by a variable in the PlantUML code for example:

```
state Connecting #000001;line:000001
```

Where the `01` is the hexadecimal representation of the identifier of the state.

To generate this code the following method is used:

```python
def get_plantuml_code(self, code_type: CodeType = CodeType.STANDARD) -> str:
```

The first part of the code is standard and does not depend on the type of the code.

```python
standard_code = f"state {self.get_variable_name()}"
```

The next part is added on whether the display name is `None` or not.

```python
if self.display_name:
    standard_code = f"{standard_code} as \"{self.display_name}\""
```

Then depending on the type of the code the appropriate code is returned.

```python
match code_type:
    case CodeType.STANDARD:
        return standard_code
    case CodeType.SELECTED:
        return f"{standard_code} #line:FF0000;line.bold"
    case CodeType.MASKED:
        return f"{standard_code} #0000{self.identifier:02X};line:0000{self.identifier:02X}"
```

### Get state variable name

For a state the variable name is simply the name of the state. This is generated by the following method:

```python
def get_variable_name(self) -> str:
    return f"{self.name}"
```

### Set state from PlantUML code

To set the attributes of the state from the PlantUML code, the following method is used:

```python
@classmethod
def from_plantuml_code(cls, plantuml_code: str):
```

The method first extracts the name of the state which is the first word after the `state` keyword.

```python
match = re.search(r'state\s+(\w+)', plantuml_code)
name = match.group(1) if match else None
```

If the display name is specified, it can be extracted as the text after "as" and between quotes.

```python
display_match = re.search(r'as\s+"([^"]+)"', plantuml_code)
display_name = display_match.group(1) if display_match else None
```

The identifier is set to default value of `0` as this is not used for a state.

```python
identifier = 0
```

The class method can then be called with the `cls` parameter set to `State`.

```python
return cls(identifier, name, display_name)
```

## Choice-point

The `ChoicePoint` class is a subclass of `Element` with the type set to `ChoicePoint` and is responsible for holding the data of a choice-point.

### Attributes

The `ChoicePoint` class has the following additional attributes:

- `name`: a string containing the name of the choice-point.
- `question`: a string containing the question of the choice-point.

### Constructor

The constructor of the class takes the following arguments:

```python
    def __init__(self, identifier: int, name: str, question: str):
        super().__init__(ElementType.CHOICE_POINT, identifier)
        self.name = name
        self.question = question
```

### Methods

The `ChoicePoint` class has the following methods:

- [`get_plantuml_code(code_type: CodeType = CodeType.STANDARD)`](#get-choice-point-plantuml-code): returns the PlantUML code of the choice-point, depending on the type of the code.
- [`get_variable_name()`](#get-choice-point-variable-name): returns the variable name of the choice-point.
- [`from_plantuml_code(plantuml_code: str)`](#set-choice-point-from-plantuml-code): classmethod that sets the attributes of the choice-point from the PlantUML code.

### Get choice-point PlantUML code

For `code_type` set to `STANDARD` a choice-point is represented by a variable in the PlantUML code for example:

```
state CP_Whitelisted as "Is Server\nWhitelisted?"
```

For `code_type` set to `SELECTED` a choice-point is represented by a variable in the PlantUML code for example:

```
state CP_Whitelisted as "Is Server\nWhitelisted?" #line:FF0000;line.bold
```

For `code_type` set to `MASKED` a choice-point is represented by a variable in the PlantUML code for example:

```
state CP_Whitelisted as "Is Server\nWhitelisted?" #000002;line:000002
```

Where the `02` is the hexadecimal representation of the identifier of the choice-point.

To generate this code the following method is used:

```python
def get_plantuml_code(self, code_type: CodeType = CodeType.STANDARD) -> str:
```

To generate the code the following steps are taken:

1. Check whether the `question` ends with a question mark and add this when this is not the case.
2. Return the appropriate code depending on the type of the code.

```python
if not self.question.endswith("?"):
    self.question += "?"
standard_code = f"state {self.get_variable_name()} as \"{self.question}\""
```

Then depending on the type of the code the appropriate code is returned.

```python
match code_type:
    case CodeType.STANDARD:
        return standard_code
    case CodeType.SELECTED:
        return f"{standard_code} #line:FF0000;line.bold"
    case CodeType.MASKED:
        return f"{standard_code} #0000{self.identifier:02X};line:0000{self.identifier:02X}"
```

### Get choice-point variable name

For a choice-point the variable name is `CP_<name>`. This is generated by the following method:

```python
def get_variable_name(self) -> str:
    return f"CP_{self.name}"
```

### Set choice-point from PlantUML code

To set the attributes of the choice-point from the PlantUML code, the following method is used:

```python
@classmethod
def from_plantuml_code(cls, plantuml_code: str):
```

An example of the code that needs to be set is:

```
state CP_Whitelisted as "Is Server\nWhitelisted?"
```

The method first creates a match with the regex `r'state\s+CP_(\w+)'` to capture the name after `CP_` in the state declaration.

```python
match = re.search(r'state\s+CP_(\w+)', plantuml_code)
name = match.group(1) if match else None
```

Next, to extract the question, the method creates a match with the regex `r'as\s+"([^"]+)"'` to capture the text after `as` and between quotes.

```python
question_match = re.search(r'as\s+"([^"]+)"', plantuml_code)
question = question_match.group(1) if question_match else None
```

The identifier is set to default value of `0` as this is not used for a choice-point.

```python
identifier = 0
```

The class method can then be called with the `cls` parameter set to `ChoicePoint`.

```python
return cls(identifier, name, question)
```

## Transition

The `Transition` class is a subclass of `Element` with the type set to `Transition` and is responsible for holding the data of a transition.

### Attributes

The `Transition` class has the following additional attributes:

- `source_state`: a string containing the variable name of the source state of the transition.
- `target_state`: a string containing the variable name of the target state of the transition.
- `connector_type`: an enum (`Left`, `Right`, `Up`, `Down`) containing the type of the connector of the transition.
- `connector_length`: an integer containing the length of the connector of the transition.
- `messages`: a list of strings containing message variable names.

### Constructor

The constructor of the class takes the following arguments of which the messages is optional because it can be empty.

```python
    def __init__(self, identifier: int, source_state: str, target_state: str, connector_type: ConnectorType, connector_length: int, messages: list[str] | None = None):
        super().__init__(ElementType.TRANSITION, identifier)
        self.source_state = source_state
        self.target_state = target_state
        self.connector_type = connector_type
        self.connector_length = connector_length
        self.messages = messages if messages is not None else []
```

### Methods

The `Transition` class has the following methods:

- [`get_plantuml_code(code_type: CodeType = CodeType.STANDARD)`](#get-transition-plantuml-code): returns the PlantUML code of the transition, depending on the type of the code.
- [`get_variable_name()`](#get-transition-variable-name): returns the variable name of the transition.
- [`from_plantuml_code(plantuml_code: str)`](#set-transition-from-plantuml-code): classmethod that sets the attributes of the transition from the PlantUML code.

### Get transition PlantUML code

For `code_type` set to `STANDARD` a transition is represented by a variable in the PlantUML code for example:

```
Connecting -> Advertising : $RTx_ConnectReq\n$RTx_ConnectedInd
```

For `code_type` set to `SELECTED` a transition is represented by a variable in the PlantUML code for example:

```
Connecting -[#FF0000,bold]> Advertising : $RTx_ConnectReq\n$RTx_ConnectedInd
```

For `code_type` set to `MASKED` a transition is represented by a variable in the PlantUML code for example:

```
Connecting -[#000003,000003]> Advertising : $RTx_ConnectReq\n$RTx_ConnectedInd
```

Where the `03` is the hexadecimal representation of the identifier of the transition.

To generate this code the following method is used:

```python
def get_plantuml_code(self, code_type: CodeType = CodeType.STANDARD) -> str:
```

The method returns the PlantUML code of the transition. This is less trivial because of the connector type and length.

The arrow depends on the type of the code.

```python
arrow_code_type = ""
match code_type:
    case CodeType.STANDARD:
        arrow_code_type = ""
    case CodeType.SELECTED:
        arrow_code_type = "[#FF0000,bold]"
    case CodeType.MASKED:
        arrow_code_type = f"[#0000{self.identifier:02X},0000{self.identifier:02X},thickness=8]"
```

Now the connector type is checked and the appropriate code is generated, following the example of the PlantUML code below where the `UP` and `DOWN` connectors are elongated:

```
STATE -left[#FF0000,bold]-> LEFT
STATE -[#FF0000,bold]> RIGHT
STATE --up[#FF0000,bold]-> UP
STATE --[#FF0000,bold]-> DOWN
```

```python
connector_code = ""
match self.connector_type:
    case ConnectorType.LEFT:
        connector_code = f"-left{arrow_code_type}->"
    case ConnectorType.RIGHT:
        connector_code = f"-{arrow_code_type}>"
    case ConnectorType.UP:
        connector_code = f"-up{arrow_code_type}->"
    case ConnectorType.DOWN:
        connector_code = f"-{arrow_code_type}->"
```

With this set, it is checked whether the `connector_type` is `UP` or `DOWN`. If this is the case, the `connector_length` is checked. When this is greater that 1, additional `-` characters are added to the connector code.

```python
if self.connector_type in [ConnectorType.UP, ConnectorType.DOWN]:
    for _ in range(self.connector_length - 1):
        connector_code += "-"
```

Next the first part of the transition can be generated by adding the source state, the connector code and the arrow code and then the target state.

```python
transition_code = f"{self.source_state.name} {connector_code} {self.target_state.name}"
```

Finally the messages are added to the transition code. This is only done if there are any messages. If that is the case, first a `:` is added and then the messages separated by a new line character. This can then be returned.

```python
if len(self.messages) > 0:
    transition_code += " : "
    for message in self.messages:
        transition_code += f"{message.get_variable_name()}\\n"
return transition_code
```

### Get transition variable name

For a transition the variable name is not used and is not generated. To prevent an error the following method is defined but does nothing.

```python
def get_variable_name(self) -> str:
    pass
```

### Set transition from PlantUML code

To set the attributes of the transition from the PlantUML code, the following method is used:

```python
@classmethod
def from_plantuml_code(cls, plantuml_code: str):
```

Some examples of the code that needs to be set are:

```
Connecting --> Advertising
Connecting -> Advertising : $RTx_ConnectReq
Connecting -up-> Advertising : $RTx_ConnectReq\n$RTx_ConnectedInd
Connecting -----> Advertising : $RTx_ConnectReq\n$RTx_ConnectedInd
```

The method first splits the `plantuml_code` based on spaces.

```python
parts = plantuml_code.split()
```

The source state is the first part.

```python
source_state = parts[0]
```

The connector is the second part.

```python
connector = parts[1]
```

To determine the connector type, the following is done:

- If the connector contains `-up`, the connector type is set to `UP`.
- If the connector contains `-right`, the connector type is set to `RIGHT`.
- If the connector contains `--`, the connector type is set to `DOWN`.
- Otherwise the connector type is set to `LEFT`.

```python
connector_type = ConnectorType.UP if "-up" in connector else ConnectorType.RIGHT if "-right" in connector else ConnectorType.DOWN if "--" in connector else ConnectorType.LEFT
```

If the connector type is `UP` or `DOWN`, the connector length is set to the number of `-` characters in the connector minus 1.

```python
connector_length = connector.count("-") - 1 if connector_type in [ConnectorType.UP, ConnectorType.DOWN] else 1
```

The target state is the third part.

```python
target_state = parts[2]
```

The messages are the remaining parts after the ":" character.

```python
messages_list = parts[4:]
```

The messages in this list are not `Message` objects yet because they are formatted as the variable name of the message. To convert them to `Message` objects, the message can be converted to the PlantUML message variable name and then use it to set the message.

```python
messages = []
for message in messages_list:
    message_variable_name = f"!{message}"
    message_object = Message(0, message_variable_name, None)
    messages.append(message_object)
```

The identifier is set to default value of `0` as this is not known at this point.

```python
identifier = 0
```

The class method can then be called with the `cls` parameter set to `Transition`.

```python
return cls(identifier, source_state, target_state, connector_type, connector_length, messages)
```
